### Функциональные выражения в JavaScript.

Функциональные выражения в JavaScript — это один из способов определения функций, когда функция создается как часть 
выражения и обычно присваивается переменной. Они отличаются от функциональных деклараций (объявлений) и имеют свои 
особенности.

---

### **Что такое функциональное выражение?**

Функциональное выражение — это функция, которая определяется внутри выражения (например, присваивания переменной) и 
не имеет собственного имени (анонимная функция) или имеет имя (именованное функциональное выражение). Оно создается 
с помощью ключевого слова `function` в контексте выражения.

Пример функционального выражения:
```javascript
const greet = function(name) {
    return `Привет, ${name}!`;
};
console.log(greet("Алексей")); // Привет, Алексей!
```

---

### **Виды функциональных выражений**

1. **Анонимное функциональное выражение**:
   - Функция без имени, присваиваемая переменной.
   ```javascript
   const add = function(a, b) {
       return a + b;
   };
   console.log(add(2, 3)); // 5
   ```

2. **Именованное функциональное выражение**:
   - Функция с указанным именем, которое доступно только внутри самой функции (удобно для рекурсии).
   ```javascript
   const factorial = function calc(n) {
       if (n <= 1) return 1;
       return n * calc(n - 1); // Имя calc доступно только внутри
   };
   console.log(factorial(5)); // 120
   // console.log(calc(5)); // Ошибка: calc не определен
   ```

3. **Стрелочные функции (ES6+)**:
   - Краткий синтаксис функциональных выражений, введенный в ES6. Не имеют собственного `this` и `arguments`.
   ```javascript
   const multiply = (a, b) => a * b;
   console.log(multiply(4, 5)); // 20
   ```

4. **IIFE (Immediately Invoked Function Expression)**:
   - Функциональное выражение, которое вызывается сразу после создания. Используется для изоляции области видимости.
   ```javascript
   (function() {
       console.log("Я выполняюсь сразу!");
   })();
   // Вывод: Я выполняюсь сразу!
   ```

---

### **Особенности функциональных выражений**

1. **Отсутствие поднятия (Hoisting)**:
   - В отличие от функциональных деклараций (`function name() {}`), функциональные выражения не поднимаются (hoisted). Их нельзя использовать до объявления.
   ```javascript
   console.log(myFunc()); // Ошибка: myFunc не определен
   const myFunc = function() {
       return "Привет!";
   };
   ```

2. **Гибкость**:
   - Функциональные выражения можно присваивать переменным, передавать как аргументы или возвращать из других функций.
   ```javascript
   function execute(func) {
       return func();
   }
   const sayHello = function() {
       return "Привет!";
   };
   console.log(execute(sayHello)); // Привет!
   ```

3. **Анонимность**:
   - Анонимные функции не имеют имени, что делает их удобными для одноразового использования, например, в качестве коллбэков.
   ```javascript
   setTimeout(function() {
       console.log("Через 1 секунду!");
   }, 1000);
   ```

4. **Контекст `this` в стрелочных функциях**:
   - Стрелочные функции не создают собственный `this`, а наследуют его из окружающей области видимости.
   ```javascript
   const obj = {
       name: "Алексей",
       sayName: function() {
           const arrow = () => console.log(this.name);
           arrow();
       }
   };
   obj.sayName(); // Алексей
   ```

5. **Использование в замыканиях**:
   - Функциональные выражения часто применяются для создания замыканий (closures), сохраняющих доступ к переменным из внешней области.
   ```javascript
   function counter() {
       let count = 0;
       return function() {
           return ++count;
       };
   }
   const myCounter = counter();
   console.log(myCounter()); // 1
   console.log(myCounter()); // 2
   ```

---

### **Отличия от функциональных деклараций**

| Характеристика                | Функциональное выражение                       | Функциональная декларация                  |
|-------------------------------|-----------------------------------------------|--------------------------------------------|
| Синтаксис                    | `const func = function() {}`                 | `function func() { aspectos: [] }`           |
| Поднятие (Hoisting)          | Нет, нельзя использовать до объявления        | Да, доступна до объявления                 |
| Имя функции                  | Может быть анонимной или именованной          | Всегда именованная                     |
| Использование                | Гибкое (переменные, аргументы, IIFE)         | Обычно для глобальных функций              |

Пример:
```javascript
// Декларация
function sayHi() {
    console.log("Привет!");
}
sayHi(); // Работает до объявления

// Выражение
const sayHello = function() {
    console.log("Привет!");
};
sayHello(); // Работает только после объявления
```

---

### **Когда использовать функциональные выражения?**

- **Коллбэки**: Передача функции в качестве аргумента (например, для `setTimeout`, `map`, `filter`).
- **Замыкания**: Создание функций с сохранением контекста.
- **IIFE**: Изоляция области видимости для предотвращения загрязнения глобального пространства.
- **Динамическое создание функций**: Когда функция создается во время выполнения программы.

---

### **Примеры использования**

1. **Коллбэк в массиве**:
```javascript
const numbers = [1, 2, 3];
const doubled = numbers.map(function(num) {
    return num * 2;
});
console.log(doubled); // [2, 4, 6]
```

2. **IIFE для инициализации**:
```javascript
const result = (function() {
    const secret = "секрет";
    return `Значение: ${secret}`;
})();
console.log(result); // Значение: секрет
```

3. **Стрелочная функция в объекте**:
```javascript
const person = {
    name: "Алексей",
    greet: () => console.log(`Привет, ${person.name}!`) // this не привязан к person
};
person.greet(); // Привет, Алексей!
```

---

### **Ключевые моменты**
- Функциональные выражения — это функции, определенные внутри выражений, часто присваиваемые переменным.
- Они не поднимаются (hoisted), что делает их поведение более предсказуемым.
- Стрелочные функции — это краткий вариант функциональных выражений с особенностями в работе с `this`.
- Используются для коллбэков, замыканий, IIFE и динамического создания функций.