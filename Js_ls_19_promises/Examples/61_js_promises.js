/* 
Давайте простую логику вывода сообщеня на экран, в зависимости от случайного числа, с задержкой:
        setTimeout(() => {
                if (Math.random() > 0.5) {
                        console.log('Успех!'); // станет resolve
                } else {
                        console.log('Ошибка!'); // станет reject
                }
        }, 1000);

Обернем в promise.

Поскольку promise представляет собой объект, который "обещает" (promise) вернуть в будущем,
некий результат или ошибку, что тоже результат, то мы всегда должны ожидать некий ответ -
return. В нашем примере стрелочная функция делает это не явно.

Параметры конструктора:

resolve: Функция, вызываемая для завершения Promise с успешным результатом. Передаёт значение, которое будет доступно в .then (см. ниже).
reject: Функция, вызываемая при ошибке (см.выше). Передаёт причину ошибки, которая будет доступна в .catch (см.ниже).

Функция-исполнитель выполняется немедленно при создании Promise.
*/

const myPromise = new Promise((resolve, reject) => {
        let rndRes = Math.random();
        // Асинхронная операция
        setTimeout(() => {
                if (rndRes > 0.5) {
                        resolve(`Успех и: ${rndRes}`); // Промис вернет результат
                } else {
                        reject(`Ошибка и: ${rndRes}`); // Тут можно было бросить ошибку, что бы все по феньшую
                }
        }, 1000);
});

console.log(myPromise); // Состояние промиса
setTimeout(() => {
        console.log(myPromise)
        console.log("----------------------------------------------------------------")
}, 990); // Зададим задержку

/* 
После создания Promise взаимодействие с ним осуществляется через методы .then, .catch и .finally.
*/
myPromise
    .then(result => console.log("Имитация ответа : " + result))
    .catch(error => console.error("Имитация ошибки : " + error));

setTimeout(() => console.log(myPromise), 1200); // Состояние промиса