### Наследование от Array в JavaScript

Пример использования классов и наследования в JavaScript (ES6+). 

Код создаёт пользовательский класс `CustomArray`, который **расширяет (extends)** встроенный класс `Array`, добавляя к нему новый метод `sum()`. В результате мы получаем "усиленный" массив с дополнительной функциональностью, но при этом он сохраняет все свойства и поведение обычного массива.

#### Исходный код:
```javascript
class CustomArray extends Array {
  sum() {
    return this.reduce((acc, val) => acc + val, 0);
  }
}

const myCustomArr = new CustomArray(1, 2, 3, 5, 8);
```

Этот код:
- Определяет класс `CustomArray`, наследующий от `Array`.
- Добавляет метод `sum()`, который суммирует все элементы массива с помощью `reduce()` (унаследованного метода).
- Создаёт экземпляр `myCustomArr` с начальными элементами `[1, 2, 3, 5, 8]`.

Теперь разберём ключевые понятия: **родитель**, **наследник**, **родные методы**, **унаследованные методы** и связанные аспекты. Я буду использовать термины на русском и английском для ясности.

#### 1. **Родитель (Parent / Superclass / Base Class)**
   - **Родительский класс**: `Array` — это встроенный (built-in) класс JavaScript, который представляет массивы. Он предоставляет базовую функциональность для работы с коллекциями элементов (например, хранение элементов по индексам, свойство `length`).
   - **Что даёт родитель?** Все стандартные свойства и методы массивов в JS. Без наследования от `Array` наш класс не вёл бы себя как настоящий массив (например, не имел бы автоматического управления длиной или индексацией).
   - В прототипной модели JS (которая лежит в основе классов) прототип `CustomArray` ссылается на прототип `Array`.

#### 2. **Наследник (Child / Subclass / Derived Class)**
   - **Наследующий класс**: `CustomArray` — это класс, который "расширяет" `Array` с помощью ключевого слова `extends`. Он наследует всё от родителя и может добавлять/переопределять своё.
   - **Что происходит при наследовании?**
     - `CustomArray` получает доступ ко всем методам и свойствам `Array`.
     - Экземпляры `CustomArray` (как `myCustomArr`) являются полноценными массивами, но с расширениями.
     - В цепочке прототипов: `myCustomArr.__proto__` → `CustomArray.prototype` → `Array.prototype` → `Object.prototype`.
   - **Проверка наследования**: 
     - `myCustomArr instanceof CustomArray` вернёт `true` (прямой класс).
     - `myCustomArr instanceof Array` вернёт `true` (унаследованный класс).
     - `myCustomArr instanceof Object` вернёт `true` (все объекты в JS наследуют от Object).

#### 3. **Родные методы (Own Methods / Non-inherited Methods)**
   - Это методы, определённые напрямую в классе `CustomArray`, а не унаследованные от родителя.
   - В примере: `sum()` — это родной метод `CustomArray`.
     - Он вычисляет сумму элементов: `this.reduce((acc, val) => acc + val, 0)`.
     - `this` здесь ссылается на экземпляр массива (например, `[1, 2, 3, 5, 8]`).
     - Вызов: `myCustomArr.sum()` вернёт `19` (1 + 2 + 3 + 5 + 8).
     - Это собственное свойство: `CustomArray.prototype.hasOwnProperty('sum')` вернёт `true`.
   - Родные методы хранятся в `CustomArray.prototype` и не существуют в `Array.prototype`.
   - Если добавить больше методов в `CustomArray` (например, `average()`), они тоже будут родными.

#### 4. **Унаследованные методы (Inherited Methods)**
   - Это методы, которые `CustomArray` получает "в наследство" от `Array`. Они доступны на экземплярах `CustomArray`, но не определены в самом классе.
   - Примеры унаследованных методов из `Array`:
     - `reduce()`: Используется внутри `sum()` для накопления значения.
     - `map()`: Преобразует элементы, например, `myCustomArr.map(x => x * 2)` вернёт `[2, 4, 6, 10, 16]`.
     - `filter()`: Фильтрует, например, `myCustomArr.filter(x => x > 3)` вернёт `[5, 8]`.
     - `push()`, `pop()`, `shift()`, `unshift()`: Для добавления/удаления элементов.
     - `forEach()`, `find()`, `includes()` и многие другие (всего около 40 методов в Array.prototype).
     - Свойства: `length` (автоматически равно 5 для `myCustomArr`).
   - Эти методы не являются "собственными" для `CustomArray`: `CustomArray.prototype.hasOwnProperty('reduce')` вернёт `false`, но `'reduce' in myCustomArr` вернёт `true` (из-за прототипной цепочки).
   - Важно: Наследование от `Array` позволяет экземплярам вести себя как настоящие массивы (с индексами, итерацией через `for...of` и т.д.). Без `extends Array` это был бы просто объект, имитирующий массив.

#### 5. **Другие аспекты (прототипы, конструктор, нюансы)**
   - **Конструктор (Constructor)**:
     - В `CustomArray` конструктор неявно наследуется от `Array`. Поэтому `new CustomArray(1, 2, 3)` работает как `new Array(1, 2, 3)` — создаёт массив с этими элементами.
     - Если нужно переопределить конструктор, можно добавить `constructor(...args) { super(...args); }`, но здесь это не требуется.
   - **Прототипная цепочка (Prototype Chain)**:
     - `CustomArray.prototype` наследует от `Array.prototype`.
     - Проверка: `Object.getPrototypeOf(CustomArray.prototype) === Array.prototype` вернёт `true`.
     - Это позволяет доступ к унаследованным методам через поиск по цепочке.
   - **Собственные свойства прототипа**:
     - Для `CustomArray.prototype`: Содержит только `constructor` (автоматически) и `sum` (добавленный).
     - Для `Array.prototype`: Содержит все встроенные методы вроде `reduce`, `map` и т.д.
   - **Нюансы наследования от Array**:
     - В JS наследование от встроенных классов (как Array, Date) работает, но имеет тонкости. Например, `CustomArray` сохраняет "массивоподобность" (array-like behavior), включая правильную работу с `length` и индексами.
     - Если добавить элементы: `myCustomArr.push(13)` — массив станет `[1, 2, 3, 5, 8, 13]`, и `sum()` учтёт это.
     - Переопределение методов: Можно переопределить унаследованный метод, например, добавить `reduce() { ... }` в `CustomArray`, но в примере этого нет.
     - Ошибки: Если массив пустой, `sum()` вернёт 0 (благодаря начальному значению в reduce). Без initialValue в reduce (если нет элементов) была бы ошибка.
   - **Когда это полезно?** Для создания специализированных коллекций, например, массива с математическими операциями (sum, average) или валидацией элементов.

#### Пример использования в коде:
```javascript
console.log(myCustomArr); // [1, 2, 3, 5, 8]
console.log(myCustomArr.sum()); // 19
console.log(myCustomArr.reduce((acc, val) => acc * val, 1)); // 120 (унаследованный reduce для произведения)
console.log(myCustomArr.length); // 5
myCustomArr.push(13);
console.log(myCustomArr.sum()); // 32
```

В итоге, этот подход позволяет расширять встроенные типы JS без потери их функциональности.