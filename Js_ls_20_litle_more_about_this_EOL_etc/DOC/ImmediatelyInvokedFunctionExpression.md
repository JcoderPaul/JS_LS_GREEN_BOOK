IIFE (Immediately Invoked Function Expression) в JavaScript — это выражение функции, которое определяется и немедленно вызывается. Это паттерн, используемый для создания локальной области видимости, предотвращения загрязнения глобального пространства имён и выполнения кода сразу после его определения.

### Синтаксис:

```javascript
(function() {
  // Код внутри функции
})();
```

- **`(function() { ... })`**: Определяет анонимную функцию (функциональное выражение).
- **`()()`**: Внешние скобки делают функцию выражением, а последующие `()` немедленно вызывают её.

### Как работает:

IIFE создаёт изолированную область видимости, где переменные, объявленные внутри, не попадают в глобальную область. После выполнения код внутри IIFE завершает свою работу, и память освобождается (если нет замыканий).

### Примеры:

1. **Изоляция переменных**:

```javascript
(function() {
  var localVar = "Я локальная!";
  console.log(localVar); // "Я локальная!"
})();
console.log(typeof localVar); // undefined (переменная не доступна снаружи)
```

2. **Предотвращение конфликтов**:

```javascript
(function() {
  var x = 10;
  console.log(x); // 10
})();
(function() {
  var x = 20; // Не конфликтует с предыдущей переменной x
  console.log(x); // 20
})();
```

3. **Передача параметров**:

```javascript
(function(name) {
  console.log(`Привет, ${name}!`);
})("Алиса"); // "Привет, Алиса!"
```

4. **Использование с объектами**:

```javascript
const counter = (function() {
  let count = 0;
  return {
    increment: function() {
      return ++count;
    },
    getCount: function() {
      return count;
    }
  };
})();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
```
Здесь IIFE создаёт замыкание, сохраняя приватную переменную `count`.

### Варианты записи:

- **Анонимная функция**:

```javascript
(function() {
  console.log("IIFE!");
})();
```

- **Именованная функция** (для отладки или рекурсии):

```javascript
(function myIIFE() {
  console.log("Именованная IIFE!");
})();
```

- **Стрелочная функция** (ES6+):

```javascript
(() => {
  console.log("Стрелочная IIFE!");
})();
```

- **С другими операторами** (для превращения в выражение):

```javascript
!function() {
  console.log("IIFE с оператором !");
}();
```
Используются `!`, `+`, `-`, `void` и т.д., чтобы сделать функцию выражением, хотя скобки — наиболее распространённый способ.

### Практическое применение:

1. **Избежание загрязнения глобального пространства**:
   IIFE предотвращает создание глобальных переменных, что снижает риск конфликтов в большом коде.

   ```javascript
   (function() {
     var temp = "Временная переменная";
     console.log(temp); // Доступно только внутри IIFE
   })();
   ```

2. **Инициализация кода**:
   Используется для выполнения одноразовых настроек, например, инициализации модуля.

   ```javascript
   const module = (function() {
     return {
       init: function() {
         console.log("Модуль инициализирован!");
       }
     };
   })();
   module.init(); // "Модуль инициализирован!"
   ```

3. **Создание замыканий**:
   IIFE часто используется для создания приватных данных через замыкания.

   ```javascript
   const createCounter = (function() {
     let count = 0;
     return function() {
       return ++count;
     };
   })();
   console.log(createCounter()); // 1
   console.log(createCounter()); // 2
   ```

4. **Работа с асинхронным кодом** (до появления async/await):

   ```javascript
   (function() {
     setTimeout(function() {
       console.log("Асинхронный вызов через 1 сек");
     }, 1000);
   })();
   ```

### Преимущества:

- **Изоляция**: Переменные внутри IIFE не конфликтуют с внешним кодом.
- **Одноразовое выполнение**: Идеально для инициализации или выполнения кода, который нужен только один раз.
- **Чистота кода**: Снижает вероятность ошибок из-за глобальных переменных.
- **Замыкания**: Позволяет создавать приватные данные и методы.

### Ограничения:

- **Однократное выполнение**: IIFE нельзя вызвать повторно, так как она выполняется сразу.
- **Отладка**: Анонимные IIFE сложнее отлаживать, если не дать функции имя.
- **Современные альтернативы**: В ES6+ модули и блоки `{}` с `let`/`const` часто заменяют IIFE для изоляции переменных:

  ```javascript
  {
    let localVar = "Локальная";
    console.log(localVar); // "Локальная"
  }
  console.log(typeof localVar); // undefined
  ```

### Когда использовать:

- Когда нужно изолировать код от глобальной области видимости.
- Для создания модулей или замыканий с приватными данными.
- Для одноразовой инициализации (например, настройка приложения).
- В старом коде, где нет поддержки ES6-модулей или блоков с `let`/`const`.

IIFE — мощный и широко используемый паттерн, особенно в старом JavaScript-коде, хотя в современном коде его роль частично заменили модули и блочная область видимости.