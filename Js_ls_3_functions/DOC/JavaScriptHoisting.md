### Hoisting

**Всплытие** (hoisting) в JavaScript — это механизм, при котором объявления переменных и функций "поднимаются" в начало своей области видимости (scope) перед выполнением кода. Это поведение связано с тем, как JavaScript интерпретирует и выполняет код в два этапа: **создание (creation phase)** и **выполнение (execution phase)**. Рассмотрим подробнее.

### Как работает всплытие

1. **Этап создания**:
   - JavaScript сначала сканирует код и "поднимает" объявления переменных (`var`, `let`, `const`) и функций (`function declarations`) в начало их области видимости (глобальной или функциональной).
   - Для переменных, объявленных с `var`, создается место в памяти, и они инициализируются значением `undefined`.
   - Для `let` и `const` объявления тоже поднимаются, но они остаются в "временной мертвой зоне" (Temporal Dead Zone, TDZ) до момента их объявления в коде.
   - Объявления функций полностью поднимаются, включая их тело, и становятся доступны для вызова.

2. **Этап выполнения**:
   - Код выполняется построчно, используя уже поднятые объявления.

### Всплытие переменных

#### 1. **`var`**
Переменные, объявленные с `var`, поднимаются и инициализируются как `undefined`. Это позволяет использовать переменную до ее объявления, но до присваивания она будет `undefined`.

**Пример**:
```javascript
console.log(x); // undefined
var x = 5;
console.log(x); // 5
```
Фактически интерпретатор видит это так:
```javascript
var x; // Поднимается
console.log(x); // undefined
x = 5;
console.log(x); // 5
```

#### 2. **`let` и `const`**
Переменные, объявленные с `let` и `const`, тоже поднимаются, но не инициализируются. До строки с их объявлением они находятся в **Temporal Dead Zone**, и попытка доступа вызовет ошибку `ReferenceError`.

**Пример**:
```javascript
console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;
```
Фактически:
```javascript
// y "поднята", но находится в TDZ
console.log(y); // Ошибка
let y = 10;
```

`const` ведет себя аналогично, но дополнительно требует инициализации при объявлении:
```javascript
const z; // SyntaxError: Missing initializer in const declaration
```

### Всплытие функций

#### 1. **Объявления функций (Function Declarations)**
Объявления функций полностью поднимаются, включая их тело, поэтому их можно вызывать до объявления в коде.

**Пример**:
```javascript
sayHello(); // "Hello!"
function sayHello() {
  console.log("Hello!");
}
```
Фактически:
```javascript
function sayHello() { // Поднимается полностью
  console.log("Hello!");
}
sayHello(); // "Hello!"
```

#### 2. **Функциональные выражения (Function Expressions)**
Функциональные выражения (например, функции, присвоенные переменным) ведут себя как переменные. Если они используют `var`, поднимается только переменная (`undefined`), а если `let` или `const` — применяется TDZ.

**Пример**:
```javascript
console.log(myFunc); // undefined
myFunc(); // TypeError: myFunc is not a function
var myFunc = function() {
  console.log("Hi!");
};
```
Фактически:
```javascript
var myFunc; // Поднимается, инициализируется как undefined
console.log(myFunc); // undefined
myFunc(); // Ошибка: undefined не функция
myFunc = function() {
  console.log("Hi!");
};
```

С `let`:
```javascript
myFunc(); // ReferenceError: Cannot access 'myFunc' before initialization
let myFunc = function() {
  console.log("Hi!");
};
```

### Тонкие моменты

1. **Приоритет всплытия**:
   - Объявления функций поднимаются **выше**, чем переменные.
   ```javascript
   console.log(test); // [Function: test]
   var test = 5;
   function test() {}
   ```
   Здесь `test` сначала становится функцией, а затем перезаписывается числом `5` при выполнении.

2. **Всплытие в блоках**:
   - `var` игнорирует блоки, поднимаясь к началу функции или глобальной области.
   - `let` и `const` поднимаются в начало блока, но остаются в TDZ.
   ```javascript
   if (true) {
     console.log(a); // ReferenceError
     let a = 1;
   }
   ```

3. **Практические проблемы**:
   - Использование переменных до их объявления с `var` может привести к багам из-за `undefined`.
   - Попытка использовать `let`/`const` до объявления вызовет явную ошибку, что делает их более предсказуемыми.
   - Функциональные выражения с `var` часто приводят к ошибкам, если вызывать их до присваивания.

### Практические советы
- **Избегайте использования переменных до их объявления**, чтобы код был читаемым и предсказуемым.
- **Используйте `let` и `const`** вместо `var`, чтобы минимизировать ошибки из-за всплытия.
- **Размещайте функции и переменные в начале области видимости**, чтобы избежать зависимости от всплытия.
- **Понимайте разницу между объявлениями функций и функциональными выражениями**, чтобы избежать ошибок типа `TypeError`.

### Пример сложного случая
```javascript
console.log(x); // undefined
if (true) {
  function foo() {
    console.log("Foo");
  }
  var x = 10;
  foo(); // "Foo"
}
console.log(x); // 10
foo(); // "Foo" (вне блока, если не strict mode)
```
В строгом режиме (`"use strict"`) поведение `foo` может отличаться, так как функции в блоках могут не всплывать глобально.