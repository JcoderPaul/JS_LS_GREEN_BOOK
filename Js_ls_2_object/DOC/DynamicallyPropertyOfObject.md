### Что такое динамически вычисляемое свойство объекта в JavaScript

Динамически вычисляемое свойство объекта (computed property name) — это функция, введённая в ECMAScript 2015 (ES6), которая позволяет определять имя свойства объекта не статически (как в традиционных объектах), а динамически во время выполнения кода. Вместо фиксированного имени свойства вы можете использовать выражение, которое вычисляется в строку или Symbol, и это выражение помещается в квадратные скобки `[]` внутри литерала объекта. Это полезно, когда имя свойства зависит от переменных, функций или других динамических данных.

Это отличается от обычных свойств, где ключ указывается напрямую (например, `{ key: 'value' }`), и от getters/setters, которые вычисляют значение свойства, но не его имя.

### Как реализуется

Реализация проста: в литерале объекта используйте квадратные скобки для выражения, которое станет ключом. Выражение может быть любым: переменной, конкатенацией строк, вызовом функции и т.д. Главное — оно должно вычисляться в допустимый ключ (строку или Symbol).

#### Примеры

1. **С использованием переменной как ключа:**
   ```javascript
   const dynamicKey = 'age';
   const person = {
     name: 'Alice',
     [dynamicKey]: 30  // Ключ 'age' вычисляется из переменной
   };
   console.log(person);  // { name: 'Alice', age: 30 }
   ```

2. **С конкатенацией строк:**
   ```javascript
   const prefix = 'user_';
   const user = {
     [prefix + 'id']: 123,
     [prefix + 'name']: 'Bob'
   };
   console.log(user);  // { user_id: 123, user_name: 'Bob' }
   ```

3. **С вызовом функции:**
   ```javascript
   function generateKey(suffix) {
     return 'key_' + suffix;
   }
   const obj = {
     [generateKey('one')]: 'value1',
     [generateKey('two')]: 'value2'
   };
   console.log(obj);  // { key_one: 'value1', key_two: 'value2' }
   ```

4. **В деструктуризации (для чтения):**
   ```javascript
   const key = 'color';
   const style = { [key]: 'red' };
   const { [key]: extractedValue } = style;
   console.log(extractedValue);  // 'red'
   ```

Эти примеры работают в современных браузерах и Node.js, поддерживающих ES6+.

### Особенности

- **Динамичность:** Ключ вычисляется только во время создания объекта, а не при каждом доступе. Если нужно вычислять значение динамически при каждом обращении, используйте getters (например, `get fullName() { return this.first + ' ' + this.last; }`).
- **Типы ключей:** Выражение должно возвращать строку или Symbol. Числа автоматически преобразуются в строки (например, `[1 + 2]: 'three'` создаст ключ '3').
- **Совместимость:** Поддерживается в ES6+, но в старых окружениях (до ES5) нужно использовать Object.defineProperty или присваивать свойства после создания объекта (например, `obj[key] = value`).
- **Ограничения:** Нельзя использовать в классах для статических свойств без дополнительных обёрток. В nested объектах работает рекурсивно.
- **Производительность:** Минимальное влияние, но чрезмерное использование сложных выражений может усложнить код и отладку.
- **Интеграция:** Хорошо сочетается с другими ES6-фичерами, такими как shorthand-свойства (`{ [key] }` эквивалентно `{ [key]: key }`) или методами.

### Best practices

- **Используйте только когда нужно:** Предпочитайте статические ключи для лучшей читаемости и автодополнения в IDE. Динамические свойства идеальны для сценариев вроде маппинга данных из API, создания объектов на основе пользовательского ввода или генерации ключей в циклах.
- **Комбинируйте с shorthand:** Для краткости используйте `{ [key] }` вместо `{ [key]: someValue }`, если ключ и значение совпадают.
- **Избегайте сложных выражений:** Держите выражения в `[]` простыми (переменные или базовые операции), чтобы код оставался понятным. Если логика сложная, вынесите её в отдельную переменную или функцию.
- **Проверяйте типы:** Убедитесь, что выражение возвращает валидный ключ, чтобы избежать ошибок (например, null или undefined преобразуются в 'null'/'undefined').
- **Тестируйте на совместимость:** Если проект поддерживает старые браузеры, используйте Babel для транспиляции.
- **Альтернативы:** Для полностью динамических объектов рассмотрите Map вместо plain objects, так как Map позволяет любые ключи (не только строки/Symbols) и лучше подходит для динамических коллекций.

Эта фича делает JS более гибким, но её чрезмерное использование может усложнить код, так что балансируйте между динамичностью и ясностью.