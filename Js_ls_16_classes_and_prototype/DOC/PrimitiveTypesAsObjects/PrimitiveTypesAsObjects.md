### Строки и числа, примитивы, как объекты в JavaScript

В JavaScript строки и числа являются **примитивами**, но иногда ведут себя как объекты благодаря механизму 
**автоупаковки** (autoboxing). Давай разберём, как это работает, что такое примитивы, как они связаны с объектами, 
и как это проявляется в контексте строк и чисел.

---

### 1. **Примитивы в JavaScript**
Примитивы — это простейшие типы данных, которые не являются объектами и не имеют методов или свойств. 

В JavaScript существуют следующие примитивные типы:
- `string` (строки, например, `"hello"`)
- `number` (числа, например, `42`, `3.14`)
- `bigint`
- `boolean`
- `undefined`
- `null`
- `symbol`

Примитивы:
- **Неизменяемы** (immutable): Их значение нельзя изменить. Например, преобразование строки `"hello"` в `"Hello"` создаёт новую строку, а не изменяет исходную.
- **Хранятся по значению**: При присваивании или передаче в функцию копируется само значение.
- **Не имеют собственных методов или свойств**: Например, у примитива `"hello"` нет свойства `.length` само по себе.

---

### 2. **Примитивы как объекты: Автоупаковка (Autoboxing)**
Несмотря на то, что строки и числа — примитивы, в JavaScript они могут вести себя как объекты благодаря механизму 
**автоупаковки**. Когда ты пытаешься получить доступ к свойству или методу примитива (например, `"hello".length` 
или `42.toFixed(2)`), JavaScript автоматически оборачивает примитив в соответствующий **объект-обёртку** (wrapper 
object). После выполнения операции объект-обёртка удаляется.

#### Объекты-обёртки:

- Для строк (`string`): `String`
- Для чисел (`number`): `Number`
- Для других примитивов: `Boolean`, `BigInt`, `Symbol` (но `null` и `undefined` не имеют обёрток).

#### Как работает автоупаковка:

1. Когда ты вызываешь метод или свойство на примитиве, JavaScript временно преобразует примитив в объект-обёртку.
2. Выполняется операция (например, вызов метода).
3. Объект-обёртка уничтожается, и ты продолжаешь работать с примитивом.

Пример:

```javascript
const str = "hello";
console.log(str.length); // 5
console.log(str.toUpperCase()); // "HELLO"
```
- Здесь `"hello"` — примитив. Когда ты вызываешь `str.length` или `str.toUpperCase()`, JavaScript:
  1. Создаёт временный объект `new String("hello")`.
  2. Вызывает метод или свойство (`length` или `toUpperCase`) на этом объекте.
  3. Возвращает результат и удаляет временный объект.
- В итоге ты работаешь с результатом (числом `5` или строкой `"HELLO"`), а не с объектом.

То же самое для чисел:

```javascript
const num = 42;
console.log(num.toFixed(2)); // "42.00"
```
- Примитив `42` оборачивается в `new Number(42)`, вызывается метод `toFixed`, возвращается строка `"42.00"`.

---

### 3. **Примитивы vs Объекты-обёртки**
Примитивы и их объекты-обёртки — это разные сущности. Создание объекта-обёртки явно (с помощью `new`) отличается от 
работы с примитивом.

#### Пример: Примитив vs Объект

```javascript
const strPrimitive = "hello"; // Примитив
const strObject = new String("hello"); // Объект

console.log(typeof strPrimitive); // "string"
console.log(typeof strObject); // "object"

console.log(strPrimitive.length); // 5 (автоупаковка)
console.log(strObject.length); // 5 (свойство объекта)
```
- Примитив `strPrimitive` — это просто строка.
- `strObject` — это полноценный объект с типом `"object"`, созданный через конструктор `String`.

#### Важные отличия:

1. **Тип**:
   - Примитив: `typeof "hello" === "string"`, `typeof 42 === "number"`.
   - Объект: `typeof new String("hello") === "object"`, `typeof new Number(42) === "object"`.
2. **Сравнение**:
   - Примитивы сравниваются по значению:
     ```javascript
     console.log("hello" === "hello"); // true
     ```
   - Объекты сравниваются по ссылке:
     ```javascript
     console.log(new String("hello") === new String("hello")); // false
     ```
3. **Производительность**:
   - Примитивы легче и быстрее, так как это просто значения.
   - Объекты-обёртки занимают больше памяти и создаются медленнее.
   - Рекомендация: **Не используй `new String` или `new Number` явно**, если нет особой причины. Используй примитивы, а автоупаковка позаботится о методах.

4. **Поведение в выражениях**:
   - Примитивы автоматически преобразуются в объекты при необходимости, но остаются неизменяемыми.
   - Попытка добавить свойство к примитиву не работает из-за временной природы обёртки:
     ```javascript
     const str = "hello";
     str.customProp = "test"; // Пытаемся добавить свойство
     console.log(str.customProp); // undefined (обёртка уничтожается)
     ```
     Для сравнения, у объекта это работает:
     ```javascript
     const strObj = new String("hello");
     strObj.customProp = "test";
     console.log(strObj.customProp); // "test"
     ```

---

### 4. **Методы и свойства строк и чисел**
Благодаря автоупаковке, примитивы имеют доступ к методам и свойствам своих объектов-обёрток.

#### Строки (`String`):
- **Свойства**:
  - `length`: Возвращает длину строки (`"hello".length` → `5`).
- **Методы** (некоторые примеры):
  - `toUpperCase()`, `toLowerCase()`: Изменение регистра.
  - `slice()`, `substring()`, `substr()`: Извлечение подстроки.
  - `includes()`, `startsWith()`, `endsWith()`: Поиск подстроки.
  - `split()`: Разделение строки на массив.
  - `trim()`: Удаление пробелов с краёв.
- Пример:

  ```javascript
  const str = "Hello, World!";
  console.log(str.toUpperCase()); // "HELLO, WORLD!"
  console.log(str.split(", ")); // ["Hello", "World!"]
  ```

#### Числа (`Number`):
- **Методы** (некоторые примеры):
  - `toFixed(n)`: Форматирует число с `n` знаками после запятой.
  - `toPrecision(n)`: Форматирует число с заданной точностью.
  - `toString(radix)`: Преобразует число в строку в заданной системе счисления.
  - `isNaN()`, `isFinite()`: Проверки на `NaN` или конечность (статические методы `Number`).
- Пример:

  ```javascript
  const num = 42.567;
  console.log(num.toFixed(1)); // "42.6"
  console.log(num.toString(16)); // "2a" (в шестнадцатеричной системе)
  ```

---

### 5. **Практические нюансы**
- **Неожиданное поведение с `typeof`**:

  ```javascript
  console.log(typeof "hello".toUpperCase()); // "string"
  ```
  Метод `toUpperCase` возвращает примитив, а не объект, так как обёртка уничтожается после вызова.
- **Проверка на примитив vs объект**:

  ```javascript
  const str = "hello";
  const strObj = new String("hello");
  console.log(str instanceof String); // false (примитив)
  console.log(strObj instanceof String); // true (объект)
  ```
- **Автоупаковка и производительность**:
  - Частое использование методов на примитивах не создаёт проблем, так как обёртки создаются и удаляются автоматически.
  - Но создание объектов явно (`new String`, `new Number`) может быть неэффективным.
- **Контекст `this` в методах**:
  - Внутри методов `String` или `Number` (например, `toUpperCase`) `this` ссылается на временный объект-обёртку, но ты видишь результат как примитив.

---

### Итог:

- Строки и числа в JavaScript — это **примитивы**, но благодаря **автоупаковке** они могут использовать методы и свойства объектов-обёрток (`String`, `Number`).
- Автоупаковка создаёт временный объект для доступа к методам, после чего возвращает примитив.
- Примитивы неизменяемы, сравниваются по значению и не хранят собственных свойств (в отличие от объектов-обёрток).
- Рекомендация: Используй примитивы вместо явного создания объектов (`new String`, `new Number`), так как это проще и эффективнее.