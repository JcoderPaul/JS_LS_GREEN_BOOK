### Вычисляемые имена методов в JavaScript

Вычисляемые имена методов (computed method names) — это расширение функциональности динамических имён свойств, введённое 
в ECMAScript 2015 (ES6). Оно позволяет задавать имена методов в объектах с помощью выражений, вычисляемых во время 
выполнения кода, используя квадратные скобки `[]`. Это делает код более гибким, особенно когда имена методов формируются 
динамически, например, на основе переменных, условий или данных. 

Пример:

```javascript
        const methodName = 'sayHello';
        const prefix = 'action_';
        
        const obj = {
            [methodName]() {
                return 'Hello, world!';
            },
            [`${prefix}run`]() {
                return 'Running!';
            },
            ['method' + 1]() {
                return 'Dynamic method 1';
            }
        };
        
        console.log(obj.sayHello()); // Hello, world!
        console.log(obj.action_run()); // Running!
        console.log(obj.method1()); // Dynamic method 1
```

#### Основы вычисляемых имён методов:
До ES6 методы в объектах определялись с фиксированными именами:

```javascript
const obj = {
  sayHello: function() {
    return 'Hello!';
  }
};
```

С ES6 можно использовать вычисляемые имена методов, задавая их через выражения в квадратных скобках `[]`:

```javascript
const methodName = 'greet';
const obj = {
  [methodName]() {
    return 'Hi!';
  }
};
console.log(obj.greet()); // Hi!
```

Выражение в `[]` вычисляется, и его результат становится именем метода. Это работает как для обычных методов, так и для 
генераторов или геттеров/сеттеров.

#### Примеры использования:

1. **Использование переменной для имени метода**:

   ```javascript
   const action = 'jump';
   const obj = {
     [action]() {
       return 'Jumping!';
     }
   };
   console.log(obj.jump()); // Jumping!
   ```

2. **Формирование имени с помощью шаблонной строки**:

   ```javascript
   const prefix = 'do_';
   const obj = {
     [`${prefix}task`]() {
       return 'Task done!';
     }
   };
   console.log(obj.do_task()); // Task done!
   ```

3. **Динамическое создание методов в цикле**:

   ```javascript
   const obj = {};
   for (let i = 1; i <= 3; i++) {
     obj[`method${i}`] = function() {
       return `Method ${i} called`;
     };
   }
   console.log(obj.method1()); // Method 1 called
   console.log(obj.method2()); // Method 2 called
   ```

4. **Геттеры и сеттеры с вычисляемыми именами**:

   ```javascript
   const prop = 'value';
   const obj = {
     _value: 42,
     get [prop]() {
       return this._value;
     },
     set [prop](val) {
       this._value = val;
     }
   };
   console.log(obj.value); // 42
   obj.value = 100;
   console.log(obj.value); // 100
   ```

5. **Генераторы с вычисляемыми именами**:

   ```javascript
   const genName = 'iterate';
   const obj = {
     *[genName]() {
       yield 1;
       yield 2;
       yield 3;
     }
   };
   for (const value of obj.iterate()) {
     console.log(value); // 1, 2, 3
   }
   ```

6. **Использование символов**:

   ```javascript
   const sym = Symbol('uniqueMethod');
   const obj = {
     [sym]() {
       return 'Unique method called';
     }
   };
   console.log(obj[sym]()); // Unique method called
   ```

#### Особенности и нюансы:

- **Типы выражений**: В `[]` можно использовать любое выражение, возвращающее строку или символ. Например, числа и булевы значения преобразуются в строки:

  ```javascript
  const obj = {
    [42]() {
      return 'Number method';
    }
  };
  console.log(obj['42']()); // Number method
  ```
- **Совместимость**: Поддерживается в современных браузерах и Node.js (ES6+). Для старых окружений (например, IE) требуется транспиляция через Babel.
- **Ошибки**: Если выражение в `[]` возвращает `undefined` или `null`, возникнет ошибка, так как имя метода должно быть строкой или символом:

  ```javascript
  const obj = {
    [undefined]() { // TypeError
      return 'Error';
    }
  };
  ```
- **Контекст `this`**: Вычисляемые методы ведут себя как обычные методы объекта, и `this` привязывается к объекту. Однако, если использовать стрелочные функции, `this` будет лексическим:

  ```javascript
  const obj = {
    name: 'Alice',
    ['greet']() {
      return this.name;
    },
    ['badGreet']: () => this.name // Не сработает
  };
  console.log(obj.greet()); // Alice
  console.log(obj.badGreet()); // undefined
  ```
- **Читаемость**: Вычисляемые имена делают код гибким, но сложные выражения в `[]` могут снизить читаемость.
- **Производительность**: Нет значительного влияния, но сложные вычисления в `[]` могут замедлить создание объекта при многократном выполнении.
- **Комбинация с другими фичами**: Отлично работает с сокращённой записью свойств, spread-оператором и деструктуризацией.

#### Best Practices:

- **Используйте для динамических сценариев**: Применяйте вычисляемые имена методов, когда имена зависят от внешних данных, например, API или конфигураций.
- **Держите выражения простыми**: Избегайте сложной логики в `[]`. Вычисляйте имя заранее, если оно сложное:

  ```javascript
  const key = complexFunction();
  const obj = { [key]() { return 'Result'; } };
  ```
- **Проверяйте значения**: Убедитесь, что выражение в `[]` возвращает строку или символ, чтобы избежать ошибок.
- **Избегайте стрелочных функций**: Для методов используйте обычные функции, чтобы сохранить правильную привязку `this`.
- **Документируйте логику**: Если имена методов формируются динамически, добавляйте комментарии для пояснения:

  ```javascript
  const obj = {
    // Метод для обработки события 'event1'
    ['handle_' + 'event1']() {
      return 'Event handled';
    }
  };
  ```
- **Комбинируйте с современными фичами**: Используйте с сокращённой записью или spread для лаконичности:

  ```javascript
  const method = 'process';
  const obj = { ...baseObj, [method]() { return 'Processed'; } };
  ```
- **Тестируйте в старых окружениях**: Для поддержки legacy-браузеров используйте транспиляцию.
- **Следуйте стилю команды**: Придерживайтесь принятого в проекте стиля (например, Airbnb), чтобы код был консистентным.

#### Сравнение с традиционным подходом
| Аспект                | Традиционный подход                     | Вычисляемые имена методов         |
|-----------------------|-----------------------------------------|-----------------------------------|
| Синтаксис             | `obj[prop] = function() {}` после создания | `[prop]() {}` в литерале         |
| Гибкость              | Требует отдельного шага                | Inline-вычисление                |
| Читаемость            | Более verbose                          | Зависит от сложности выражения   |
| Ошибки                | Меньше риска                          | Требует проверки на `null`/ `undefined` |

Вычисляемые имена методов — это мощный инструмент для создания гибких объектов, особенно в сценариях, где имена методов 
определяются динамически.