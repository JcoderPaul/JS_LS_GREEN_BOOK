### Три состояния Promises в JavaScript

Промисы в JavaScript (Promises) имеют ровно три возможных состояния, которые определяют этап выполнения асинхронной операции. Эти состояния описаны в спецификации ECMAScript и являются фундаментальными для понимания работы промисов. Состояние промиса может измениться только один раз: из начального в одно из финальных. 

Разберем каждое состояние подробнее, включая переходы, обработку и особенности.

#### 1. **Pending (Ожидание)**
   - **Описание**: Это начальное состояние любого промиса сразу после его создания. В этот момент асинхронная операция ещё не завершена — она выполняется в фоновом режиме (например, сетевой запрос, таймер или чтение файла). Промис "ожидает" результата и не имеет ни значения, ни ошибки.
   - **Как перейти в это состояние**: Автоматически при создании промиса с помощью `new Promise((resolve, reject) => { ... })`. Пока не вызван `resolve()` или `reject()`, промис остаётся в pending.
   - **Обработка**: В состоянии pending вы не можете получить значение или ошибку. Методы `.then()`, `.catch()` и `.finally()` регистрируют колбэки, но они не выполняются, пока состояние не изменится. Если промис навсегда остаётся в pending (например, из-за ошибки в коде, которая не вызывает resolve/reject), это может привести к "зависанию" (leaking promise), что считается плохой практикой.
   - **Особенности**:
     - Промис в pending может быть "забытым" — если не обработать его, JavaScript не выдаст ошибку, но это может привести к утечкам памяти в долгоживущих приложениях.
     - В Node.js, если промис в pending reject'нется позже без обработчика, сработает событие 'unhandledRejection'.
     - Пример: 
       ```javascript
       const pendingPromise = new Promise(() => {}); // Навсегда pending
       console.log(pendingPromise); // Promise { <pending> }
       ```
     - Полезно для операций, где время выполнения неизвестно, но избегайте бесконечных pending — всегда вызывайте resolve или reject.

#### 2. **Fulfilled (Выполнено, или Resolved)**
   - **Описание**: Промис переходит в это состояние, когда асинхронная операция успешно завершена. Теперь промис имеет значение (value), которое можно получить. Это финальное состояние — промис больше не изменится.
   - **Как перейти в это состояние**: Вызвать `resolve(value)` внутри конструктора промиса. Value может быть любым: примитивом, объектом, даже другим промисом (в этом случае цепочка ждёт его разрешения).
   - **Обработка**: Колбэки в `.then(onFulfilled)` выполняются с переданным value. Если в `.then` вернуть значение, оно передаётся дальше по цепочке. `.finally()` сработает в любом случае.
   - **Особенности**:
     - Если resolve вызван с другим промисом, исходный промис "принимает" состояние этого вложенного промиса (promise chaining).
     - Синхронные resolve: если resolve вызван сразу (синхронно), колбэки всё равно выполняются асинхронно (в микротаск-очереди), чтобы сохранить последовательность.
     - Ошибки в fulfilled: если в `.then` бросить ошибку, следующий `.catch` её поймает, и промис в цепочке станет rejected.
     - Пример:
       ```javascript
       const fulfilledPromise = new Promise((resolve) => resolve('Успех!'));
       fulfilledPromise.then(value => console.log(value)); // 'Успех!'
       console.log(fulfilledPromise); // Promise { 'Успех!' }
       ```
     - Идеально для успешных сценариев, но всегда комбинируйте с обработкой ошибок, чтобы избежать silent failures.

#### 3. **Rejected (Отклонено)**
   - **Описание**: Промис переходит в это состояние при неудачном завершении операции (ошибка, исключение). Теперь промис имеет причину отказа (reason), обычно объект Error, но может быть любым значением.
   - **Как перейти в это состояние**: Вызвать `reject(reason)` внутри конструктора, или бросить исключение (throw) синхронно в промисе — это автоматически reject с ошибкой.
   - **Обработка**: Колбэки в `.catch(onRejected)` или второй аргумент `.then(null, onRejected)` выполняются с reason. `.finally()` сработает, но не получит reason. Ошибки "пробрасываются" по цепочке, если не пойманы.
   - **Особенности**:
     - Unhandled rejection: Если reject не обработан `.catch`, в браузерах/Node.js может вывести предупреждение в консоль. В Node.js — событие 'unhandledRejection' для глобальной обработки.
     - Reject с промисом: Если reject с другим промисом, он не "разрешается" — просто передаётся как reason.
     - Автоматический reject: Синхронные throw в конструкторе приводят к reject, что полезно для валидации.
     - Пример:
       ```javascript
       const rejectedPromise = new Promise((resolve, reject) => reject(new Error('Ошибка!')));
       rejectedPromise.catch(error => console.error(error.message)); // 'Ошибка!'
       console.log(rejectedPromise); // Promise { <rejected> Error: Ошибка! }
       ```
     - Критично обрабатывать rejected, чтобы избежать необработанных ошибок, которые могут сломать приложение.

### Общие особенности состояний Promises
- **Необратимость**: Состояние меняется только из pending в fulfilled или rejected. Нет возврата назад — это гарантирует предсказуемость.
- **Асинхронность**: Даже синхронные resolve/reject выполняют колбэки асинхронно (microtasks), что влияет на порядок: промисы приоритетнее setTimeout (macrotasks).
- **Цепочки и композиция**: Состояние влияет на всю цепочку `.then()/.catch()`. `Promise.all` reject'нется, если хоть один промис rejected.
- **Ошибки**: Промисы "поглощают" ошибки, если не обработаны, но в современных окружениях есть предупреждения.
- **Совместимость с async/await**: Await ждёт, пока промис не выйдет из pending; throw при rejected.
- **Best practices**: 
  - всегда добавляйте `.catch` или try/catch; 
  - мониторьте unhandled rejections; 
  - используйте `Promise.resolve()`/`Promise.reject()` для создания уже fulfilled/rejected промисов.