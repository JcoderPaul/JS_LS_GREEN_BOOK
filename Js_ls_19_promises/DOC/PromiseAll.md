### Что такое `Promise.all` в JavaScript

`Promise.all` — это статический метод объекта `Promise`, который принимает **итерируемый объект** (обычно массив) промисов и возвращает **новый промис**. Этот новый промис разрешается (fulfilled), когда **все переданные промисы разрешены** (fulfilled), или отклоняется (rejected), если **хотя бы один промис отклонён** (rejected). Это мощный инструмент для выполнения и обработки **параллельных асинхронных операций**.

---

### Как работает `Promise.all`?

1. **Входные параметры**:
   - Принимает итерируемый объект (обычно массив) промисов, например: `[promise1, promise2, promise3]`.
   - Если передать не промисы (например, числа, строки), они автоматически оборачиваются в `Promise.resolve(value)`.

2. **Результат**:
   - Возвращает новый промис, который:
     - **Fulfilled**: Если **все** промисы в массиве разрешаются (fulfilled), возвращается массив результатов в том же порядке, в котором были переданы промисы.
     - **Rejected**: Если **хотя бы один** промис отклоняется (rejected), `Promise.all` сразу отклоняется с причиной (reason) этого промиса, игнорируя остальные (даже если они fulfilled).

3. **Параллелизм**:
   - Все промисы выполняются **параллельно** (не последовательно), что экономит время по сравнению с ожиданием каждого промиса по очереди.
   - Порядок результатов сохраняется, даже если промисы завершаются в разное время.

4. **Состояние**:
   - Находится в состоянии **pending**, пока все промисы не завершатся или один не отклонится.
   - Переходит в **fulfilled** с массивом результатов или **rejected** с первой ошибкой.

---

### Синтаксис

```javascript
Promise.all(iterable)
  .then(results => { /* обработка массива результатов */ })
  .catch(error => { /* обработка ошибки */ });
```

- `iterable`: Массив (или другой итерируемый объект) промисов.
- `results`: Массив значений, возвращённых промисами, в том же порядке.
- `error`: Причина отклонения первого неуспешного промиса.

---

### Пример использования

```javascript
// Создаём несколько промисов
const promise1 = Promise.resolve('Результат 1');
const promise2 = new Promise((resolve) => setTimeout(() => resolve('Результат 2'), 1000));
const promise3 = fetch('https://api.example.com/data').then(res => res.json());

// Используем Promise.all
Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log(results); // ['Результат 1', 'Результат 2', { данные от API }]
  })
  .catch(error => {
    console.error('Ошибка:', error.message);
  });
```

**Что происходит**:
- `promise1` разрешается сразу (`Promise.resolve`).
- `promise2` разрешается через 1 секунду.
- `promise3` делает HTTP-запрос и ждёт ответа.
- `Promise.all` ждёт завершения всех трёх промисов и возвращает массив `['Результат 1', 'Результат 2', { данные от API }]`.
- Если, например, `promise3` отклоняется из-за сбоя сети, `Promise.all` сразу отклоняется с ошибкой.

---

### Пример с ошибкой

```javascript
const promise1 = Promise.resolve('Успех 1');
const promise2 = new Promise((resolve, reject) => setTimeout(() => reject(new Error('Ошибка!')), 1000));
const promise3 = Promise.resolve('Успех 3');

Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log(results); // Не выполнится
  })
  .catch(error => {
    console.error(error.message); // 'Ошибка!'
  });
```

**Что происходит**:
- `promise2` отклоняется через 1 секунду.
- `Promise.all` сразу переходит в rejected, не дожидаясь завершения других промисов.
- `.catch` обрабатывает ошибку от `promise2`.

---

### Особенности `Promise.all`

1. **Параллельное выполнение**:
   - Все промисы запускаются одновременно, что идеально для независимых операций (например, загрузка нескольких файлов или API-запросов).

2. **Порядок результатов**:
   - Массив результатов сохраняет порядок исходного массива, даже если промисы завершаются в разное время.

3. **Короткое замыкание**:
   - Если один промис отклоняется, `Promise.all` немедленно отклоняется, игнорируя остальные промисы (хотя они продолжают выполняться в фоне).

4. **Пустой массив**:
   - Если передать пустой массив (`Promise.all([])`), промис сразу разрешается с пустым массивом `[]`.

5. **Не-промисы**:
   - Если в массиве есть не-промисы (например, `42` или `'строка'`), они автоматически преобразуются в `Promise.resolve(value)`.

6. **Микротаски**:
   - `Promise.all` работает в микротаск-очереди, что делает его выполнение приоритетным над макротасками (например, `setTimeout`).

---

### Когда использовать `Promise.all`?

- **Множественные API-запросы**: Загрузка данных с нескольких эндпоинтов одновременно.
  ```javascript
  const users = fetch('/api/users').then(res => res.json());
  const posts = fetch('/api/posts').then(res => res.json());
  Promise.all([users, posts]).then(([userData, postData]) => {
    console.log(userData, postData);
  });
  ```

- **Параллельная обработка задач**: Например, загрузка нескольких изображений или выполнение вычислений.
- **Синхронизация операций**: Когда нужно дождаться завершения всех задач перед продолжением.

---

### Best Practices

1. **Обрабатывайте ошибки**:
   - Всегда добавляйте `.catch()` или используйте `try/catch` с `async/await`, чтобы не пропустить rejected промисы.
   ```javascript
   async function fetchAll() {
     try {
       const results = await Promise.all([promise1, promise2]);
       console.log(results);
     } catch (error) {
       console.error('Ошибка:', error);
     }
   }
   ```

2. **Используйте для независимых операций**:
   - `Promise.all` подходит, когда промисы не зависят друг от друга. Если нужна последовательность, используйте цепочку `.then` или `for...await`.

3. **Альтернативы при ошибках**:
   - Если нужно дождаться завершения всех промисов, даже если некоторые отклоняются, используйте `Promise.allSettled` (возвращает массив статусов `{ status: 'fulfilled'/'rejected', value/reason }`).

4. **Ограничьте параллелизм**:
   - При большом количестве промисов (например, 100+ API-запросов) сервер может быть перегружен. Используйте библиотеки (как `p-limit`) для ограничения числа одновременных операций.

5. **Типизация (TypeScript)**:
   - Указывайте типы результатов: `Promise.all<Promise<string>[]>(...)`.

---

### Различие с другими методами

- **Promise.allSettled**: Ждёт завершения всех промисов, даже если некоторые отклонены. Возвращает массив объектов с `status` и `value`/`reason`.
- **Promise.race**: Возвращает первый завершённый промис (fulfilled или rejected).
- **Promise.any**: Возвращает первый fulfilled промис, игнорируя rejected (или `AggregateError`, если все rejected).

---

### Пример с `async/await`

```javascript
async function fetchMultiple() {
  try {
    const [result1, result2] = await Promise.all([
      Promise.resolve('Данные 1'),
      new Promise(resolve => setTimeout(() => resolve('Данные 2'), 1000))
    ]);
    console.log(result1, result2); // 'Данные 1', 'Данные 2'
  } catch (error) {
    console.error('Ошибка:', error);
  }
}
fetchMultiple();
```